# TODO
- [ ] сделать докер

# Настройка проекта
Необходимы `go 1.25`, `gnu make`, бд `Postgres`

Выполнить `make initial-setup`

Объявить переменные окружения:
- `ENV` - `local`/`dev`/`preprod`/`prod`
- `QUOTATION_UPDATE_INTERVAL_MILLISECONDS` - минимальный интервал обработки запросов на обновление котировок
- `DB_HOST`
- `DB_PORT` 
- `DB_USER`
- `DB_PASSWORD`
- `DB_NAME`
- `DB_USE_SSL` `true`/`false`
- `SERVER_IP`
- `SERVER_PORT`
- `OUTGOING_REQUEST_TIMEOUT`
- `INCOMING_REQUEST_TIMEOUT`
- `SWAGGER_USER` - необходимо только для `dev`/`preprod`
- `SWAGGER_PASSWORD` - необходимо только для `dev`/`preprod`
- `METRICS_PORT`
- `FRANKFURTER_API_URL` - `https://api.frankfurter.dev`

### Make команды
- `test` - выполняет тесты
- `run` - запускает сервер
- `lint` - запускает линтер 
- `build-swagger` - генерит свагер
- `initial-setup` - устанавливает зависимости, генератор свагера и линтер

### Где чего
Метрики доступны по `localhost:METRICS_PORT/metrics`

Сваггер доступен по `SERVER_IP:SERVER_PORT/docs/index.html`. _(Для `local` без аутентификации, для `dev`/`preprod` нужна,
для `prod` не поднимается)_

Запросить последнее известное значение котировки - `GET /api/v1/quotation/current`

Запросить обновление котировки - `POST /api/v1/quotation`

Запросить значение котировки по `Id` запроса - `GET /api/v1/quotation/{id}`

### Архитектура
Моя любимая, на данный момент, вариация на тему DDD+CQRS (без фанатизма)

Как лучше организовывать DI не успел определиться, через контекст мб. 
Пока решил логер через параметры прокидывать, все остальные сервисы - глобальный инстанс

`api` - контроллеры + сваггер

`domain` - бизнесовые сущности и логика _которой тут, по сути, нет :)_

`lib` - метрики/логер/мидлвары и прочие утилиты

`persistence` - интерфейс бд + реализации (postgres и inmemory для тестов)

`service` - внешние интеграции, внутренние сервисы (интерфейс + реализации)

`usecase` - обычно по 1 на каждый эндпоинт. Могут вызывать друг друга

### Unit тесты
Есть для [inmemory](internal/persistence/inmemory)(не то чтобы она нужна была, накидал что бы чуть побольше с языком поиграться) и 
[quotation-manager](internal/service/quotation-manager)


### Возникшие бизнесовые вопросы, на которые я сам и ответил
 - может ли котировка A/Б отличать от Б/А - да
 - запрашивать ли все возможные котировки при старте сервиса - нет _хотя, по-хорошему, конечно, стоило бы, но тут вылезает проблема, что может внешний сервис недоступен, что тогда делаем и т.д._
 - подтягивать ли последние значения котировок из базы при старте сервиса - нет _(хотя можно было бы как фолбэк, если все таки решили при старте ходить за котировками, а они не доступны._
 - что делать, если запросили последнюю котировку (не по id), а ее нет - __404 quotation was not requested yet__

### Общие мысли насчет го (в сравнении с растом)
Вначале подгорало конечно, но на третий день втянулся))

- Подводных камней вагон
- Видимо стоило [генерить контроллеры по схеме](https://go-kratos.dev/en/docs/guide/openapi/), потому что в комментах писать свагер такое себе
- Дико не хватает тип-суммы! Просто енумов тоже
- Рефлексия кастрированная и не в компайлтайме. Видимо чтобы компиляция меньше времени занимала, но по факту то все генераторами обмазываются, не уверен, что быстрее выходит
- Очень мало забот можно переложить на компилятор. А в тегах можно вообще что угодно написать и потом ловить в рантайме ошибки _(например если удалить метод `IsValid()` в `internal/domain/types/currency.go`)_
- Почему нет отступов в `switch`-е?!! Это, видимо, из С притащили, но могли бы и вынести в конфиг
- Сложилось ощущение, что фреймворки какие-то сыроватые. Я, правда, только 3 попробовал
- Компилится действительно быстро :)
- Борроу чекер не загоняет в угол, это, конечно, большой плюс, что не нужно постоянно рефакторить
- `defer` удобная штука
- Насколько быстрее писать не знаю, но такого рода сервисы точно не сильно, если вообще быстрее

P.S. 
Язык хороший, но, все таки, жалко что бизнес мою любовь к расту не разделяет